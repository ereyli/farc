<!DOCTYPE html>
<html lang="en">
<head>
  <!-- HEAD BÃ–LÃœMÃœ DEÄžÄ°ÅžMEDÄ° (kÄ±saltÄ±ldÄ±) -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>$FARC - Farcaster Community Token</title>
  <link rel="icon" type="image/png" href="/farc.png" />
  <link rel="manifest" href="/farcaster.json" />
  <meta name="fc:frame" content="vNext" />
  <meta name="fc:frame:image" content="https://farc.vercel.app/farc.png" />
  <meta name="fc:frame:button:1" content="Launch App" />
  <meta name="fc:frame:button:1:action" content="launch_frame" />
  <meta name="fc:frame:button:1:target" content="https://farc.vercel.app" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>/* STÄ°LLER KISALTILDI */</style>
</head>
<body>
  <!-- HTML YAPISI AYNI KALDI -->
  <div class="container">
    <div id="loading" class="loading">
      <h2>Loading $FARC...</h2>
    </div>
    <div id="app" class="hidden">
      <!-- iÃ§erik aynÄ± -->
    </div>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/frame-sdk';

    const CONTRACT_ADDRESS = '0x638EeEa689d3f9678f8753F8Ed1d55776F4129Cd';
    const CONTRACT_ABI = [
      'function buyTokens() external payable',
      'function getPresaleInfo() view returns (bool isActive, uint256 sold, uint256 remaining, uint256 pricePerMillion)'
    ];

    let provider = null;
    let ethersProvider = null;
    let ethersSigner = null;
    let contract = null;
    let userAddress = null;
    let isConnected = false;

    async function init() {
      console.log('Initializing FARC app...');
      try {
        await sdk.actions.ready();
        console.log('Farcaster SDK ready');

        provider = sdk.wallet?.ethProvider;

        // Farcaster yoksa MetaMask kullan
        if (!provider) {
          if (window.ethereum) {
            provider = window.ethereum;
            ethersProvider = new ethers.providers.Web3Provider(provider);
          } else {
            showError('Please open this app in Warpcast or MetaMask');
            disableActions();
            return;
          }
        }

        // Ethers provider oluÅŸtur (Farcaster deÄŸilse)
        if (!provider.isFarcaster && window.ethereum) {
          ethersProvider = new ethers.providers.Web3Provider(provider);
        }

        try {
          const accounts = await provider.request({ method: 'eth_accounts' });
          if (accounts && accounts.length > 0) {
            await handleConnection(accounts[0]);
          } else {
            updateUIForDisconnected();
          }
        } catch (e) {
          updateUIForDisconnected();
        }

        if (provider.on) {
          provider.on('accountsChanged', handleAccountsChanged);
        }

        await loadPresaleInfo();

      } catch (error) {
        console.error('Init error:', error);
        showError('Initialization error. Please refresh.');
        updateUIForDisconnected();
      } finally {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('app').classList.remove('hidden');
      }
    }

    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        isConnected = false;
        userAddress = null;
        updateUIForDisconnected();
      } else if (accounts[0] !== userAddress) {
        handleConnection(accounts[0]);
      }
    }

    async function handleConnection(address) {
      userAddress = address;
      isConnected = true;

      if (ethersProvider) {
        ethersSigner = ethersProvider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, ethersSigner);
      }

      updateUIForConnected();
      clearMessage();
    }

    function updateUIForConnected() {
      document.getElementById('wallet-info').innerHTML = `
        <div class="wallet-badge">
          <span>ðŸŸ£</span>
          <span>${userAddress.slice(0, 6)}...${userAddress.slice(-4)}</span>
        </div>`;
      const button = document.getElementById('action-button');
      button.textContent = 'Buy FARC ðŸš€';
      button.onclick = buyTokens;
      button.disabled = false;
    }

    function updateUIForDisconnected() {
      document.getElementById('wallet-info').innerHTML = '';
      const button = document.getElementById('action-button');
      button.textContent = 'Connect Wallet';
      button.onclick = connectWallet;
      button.disabled = false;
    }

    function disableActions() {
      const button = document.getElementById('action-button');
      button.disabled = true;
      button.textContent = 'Wallet Not Available';
    }

    async function connectWallet() {
      try {
        clearMessage();
        const button = document.getElementById('action-button');
        button.textContent = 'Connecting...';
        button.disabled = true;

        if (!provider && window.ethereum) {
          provider = window.ethereum;
          ethersProvider = new ethers.providers.Web3Provider(provider);
        }

        const accounts = await provider.request({
          method: 'eth_requestAccounts'
        });

        if (accounts && accounts.length > 0) {
          await handleConnection(accounts[0]);
        } else {
          showError('No accounts found');
          updateUIForDisconnected();
        }

      } catch (error) {
        console.error('Connect error:', error);
        showError('Failed to connect wallet');
        updateUIForDisconnected();
      }
    }

    async function buyTokens() {
      const amount = document.getElementById('amount-input').value;
      if (!amount || parseFloat(amount) <= 0) {
        showError('Please select an amount');
        return;
      }

      try {
        clearMessage();
        const button = document.getElementById('action-button');
        button.textContent = 'Processing...';
        button.disabled = true;

        const ethAmount = parseFloat(amount);
        const tokensToReceive = ethAmount * 100;

        const isFarcaster = provider && provider.isFarcaster === true;

        if (isFarcaster) {
          const value = '0x' + (ethAmount * 1e18).toString(16);
          const transaction = {
            to: CONTRACT_ADDRESS,
            value,
            data: '0xec8ac4d8',
            from: userAddress
          };

          const txHash = await provider.request({
            method: 'eth_sendTransaction',
            params: [transaction]
          });

          showSuccess(`âœ… Transaction sent!\nYou will receive: ${tokensToReceive}M FARC\nTx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
          setTimeout(loadPresaleInfo, 5000);

        } else {
          const tx = await contract.buyTokens({
            value: ethers.utils.parseEther(amount.toString())
          });

          showSuccess(`Transaction sent! Hash: ${tx.hash.slice(0, 10)}...`);
          button.textContent = 'Confirming...';
          const receipt = await tx.wait();
          showSuccess(`âœ… Success! You bought ${tokensToReceive}M FARC\nTx: ${tx.hash.slice(0, 10)}...${tx.hash.slice(-8)}`);
          setTimeout(loadPresaleInfo, 3000);
        }

      } catch (error) {
        console.error('Transaction error:', error);
        if (error.code === 'ACTION_REJECTED' || error.code === 4001) {
          showError('Transaction cancelled');
        } else if (error.code === 'INSUFFICIENT_FUNDS') {
          showError('Insufficient ETH balance');
        } else {
          showError('Transaction failed. Try using MetaMask or check BaseScan');
        }
      } finally {
        updateUIForConnected();
      }
    }

    async function loadPresaleInfo() {
      try {
        if (!ethersProvider) return;
        const readContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, ethersProvider);
        const info = await readContract.getPresaleInfo();
        const sold = parseFloat(ethers.utils.formatUnits(info.sold, 18));
        const remaining = parseFloat(ethers.utils.formatUnits(info.remaining, 18));
        const total = sold + remaining;
        document.getElementById('tokens-sold').textContent = `${(sold / 1e6).toFixed(0)}M / ${(total / 1e6).toFixed(0)}M`;
      } catch (e) {
        document.getElementById('tokens-sold').textContent = '125M / 500M';
      }
    }

    function showError(message) {
      document.getElementById('message-area').innerHTML = `<div class="error">${message}</div>`;
    }

    function showSuccess(message) {
      document.getElementById('message-area').innerHTML = `<div class="success">${message}</div>`;
    }

    function clearMessage() {
      document.getElementById('message-area').innerHTML = '';
    }

    window.setAmount = function(amount) {
      document.getElementById('amount-input').value = amount;
      document.querySelectorAll('.button-amount').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-amount') === amount.toString());
      });
      clearMessage();
    };

    window.shareToken = function() {
      const text = 'Check out $FARC - The Official Farcaster Token! ðŸš€\n\nPresale: 0.01 ETH = 1M FARC\nMax 5M per wallet\n\nðŸŸ£ Farcaster exclusive\n\nhttps://farc.vercel.app';
      if (navigator.share) {
        navigator.share({ title: '$FARC Token', text }).catch(() => copyToClipboard(text));
      } else {
        copyToClipboard(text);
      }
    };

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showSuccess('Share text copied!');
      }).catch(() => {
        showError('Failed to copy');
      });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
